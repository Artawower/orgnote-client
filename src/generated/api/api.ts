/* tslint:disable */
/* eslint-disable */
/**
 * Second Brain API
 * List of methods for work with second brain.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: artawower@protonmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface HandlersHttpErrorAny
 */
export interface HandlersHttpErrorAny {
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpErrorAny
     */
    'data'?: object;
    /**
     * 
     * @type {string}
     * @memberof HandlersHttpErrorAny
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseArrayModelsAPITokenAny
 */
export interface HandlersHttpResponseArrayModelsAPITokenAny {
    /**
     * 
     * @type {Array<ModelsAPIToken>}
     * @memberof HandlersHttpResponseArrayModelsAPITokenAny
     */
    'data'?: Array<ModelsAPIToken>;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseArrayModelsAPITokenAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseArrayModelsNoteModelsPagination
 */
export interface HandlersHttpResponseArrayModelsNoteModelsPagination {
    /**
     * 
     * @type {Array<ModelsNote>}
     * @memberof HandlersHttpResponseArrayModelsNoteModelsPagination
     */
    'data'?: Array<ModelsNote>;
    /**
     * 
     * @type {ModelsPagination}
     * @memberof HandlersHttpResponseArrayModelsNoteModelsPagination
     */
    'meta'?: ModelsPagination;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseArrayStringAny
 */
export interface HandlersHttpResponseArrayStringAny {
    /**
     * 
     * @type {Array<string>}
     * @memberof HandlersHttpResponseArrayStringAny
     */
    'data'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseArrayStringAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseHandlersOAuthRedirectDataAny
 */
export interface HandlersHttpResponseHandlersOAuthRedirectDataAny {
    /**
     * 
     * @type {HandlersOAuthRedirectData}
     * @memberof HandlersHttpResponseHandlersOAuthRedirectDataAny
     */
    'data'?: HandlersOAuthRedirectData;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseHandlersOAuthRedirectDataAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseModelsAPITokenAny
 */
export interface HandlersHttpResponseModelsAPITokenAny {
    /**
     * 
     * @type {ModelsAPIToken}
     * @memberof HandlersHttpResponseModelsAPITokenAny
     */
    'data'?: ModelsAPIToken;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseModelsAPITokenAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseModelsNoteAny
 */
export interface HandlersHttpResponseModelsNoteAny {
    /**
     * 
     * @type {ModelsNote}
     * @memberof HandlersHttpResponseModelsNoteAny
     */
    'data'?: ModelsNote;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseModelsNoteAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseModelsNoteGraphAny
 */
export interface HandlersHttpResponseModelsNoteGraphAny {
    /**
     * 
     * @type {ModelsNoteGraph}
     * @memberof HandlersHttpResponseModelsNoteGraphAny
     */
    'data'?: ModelsNoteGraph;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseModelsNoteGraphAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersHttpResponseModelsPublicUserAny
 */
export interface HandlersHttpResponseModelsPublicUserAny {
    /**
     * 
     * @type {ModelsPublicUser}
     * @memberof HandlersHttpResponseModelsPublicUserAny
     */
    'data'?: ModelsPublicUser;
    /**
     * 
     * @type {object}
     * @memberof HandlersHttpResponseModelsPublicUserAny
     */
    'meta'?: object;
}
/**
 * 
 * @export
 * @interface HandlersOAuthRedirectData
 */
export interface HandlersOAuthRedirectData {
    /**
     * 
     * @type {string}
     * @memberof HandlersOAuthRedirectData
     */
    'redirectUrl'?: string;
}
/**
 * 
 * @export
 * @interface ModelsAPIToken
 */
export interface ModelsAPIToken {
    /**
     * 
     * @type {string}
     * @memberof ModelsAPIToken
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAPIToken
     */
    'permission'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsAPIToken
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ModelsCategory = {
    CategoryArticle: 'article',
    CategoryBook: 'book',
    CategorySchedule: 'schedule'
} as const;

export type ModelsCategory = typeof ModelsCategory[keyof typeof ModelsCategory];


/**
 * 
 * @export
 * @interface ModelsGraphNoteLink
 */
export interface ModelsGraphNoteLink {
    /**
     * 
     * @type {string}
     * @memberof ModelsGraphNoteLink
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGraphNoteLink
     */
    'target'?: string;
}
/**
 * 
 * @export
 * @interface ModelsGraphNoteNode
 */
export interface ModelsGraphNoteNode {
    /**
     * 
     * @type {string}
     * @memberof ModelsGraphNoteNode
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsGraphNoteNode
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsGraphNoteNode
     */
    'weight'?: number;
}
/**
 * 
 * @export
 * @interface ModelsNote
 */
export interface ModelsNote {
    /**
     * 
     * @type {string}
     * @memberof ModelsNote
     */
    'authorId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsNote
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsNote
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsNote
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNote
     */
    'likes'?: number;
    /**
     * 
     * @type {ModelsNoteMeta}
     * @memberof ModelsNote
     */
    'meta'?: ModelsNoteMeta;
    /**
     * 
     * @type {string}
     * @memberof ModelsNote
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelsNote
     */
    'views'?: number;
}
/**
 * 
 * @export
 * @interface ModelsNoteGraph
 */
export interface ModelsNoteGraph {
    /**
     * 
     * @type {Array<ModelsGraphNoteLink>}
     * @memberof ModelsNoteGraph
     */
    'links'?: Array<ModelsGraphNoteLink>;
    /**
     * 
     * @type {Array<ModelsGraphNoteNode>}
     * @memberof ModelsNoteGraph
     */
    'nodes'?: Array<ModelsGraphNoteNode>;
}
/**
 * 
 * @export
 * @interface ModelsNoteHeading
 */
export interface ModelsNoteHeading {
    /**
     * 
     * @type {number}
     * @memberof ModelsNoteHeading
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteHeading
     */
    'text'?: string;
}
/**
 * 
 * @export
 * @interface ModelsNoteLink
 */
export interface ModelsNoteLink {
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteLink
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteLink
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface ModelsNoteMeta
 */
export interface ModelsNoteMeta {
    /**
     * 
     * @type {ModelsCategory}
     * @memberof ModelsNoteMeta
     */
    'category'?: ModelsCategory;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteMeta
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ModelsNoteLink>}
     * @memberof ModelsNoteMeta
     */
    'externalLinks'?: Array<ModelsNoteLink>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsNoteMeta
     */
    'fileTags'?: Array<string>;
    /**
     * 
     * @type {Array<ModelsNoteHeading>}
     * @memberof ModelsNoteMeta
     */
    'headings'?: Array<ModelsNoteHeading>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModelsNoteMeta
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {Array<ModelsNoteLink>}
     * @memberof ModelsNoteMeta
     */
    'linkedArticles'?: Array<ModelsNoteLink>;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteMeta
     */
    'previewImg'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelsNoteMeta
     */
    'published'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteMeta
     */
    'startup'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsNoteMeta
     */
    'title'?: string;
}


/**
 * 
 * @export
 * @interface ModelsPagination
 */
export interface ModelsPagination {
    /**
     * 
     * @type {number}
     * @memberof ModelsPagination
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPagination
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelsPagination
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ModelsPublicUser
 */
export interface ModelsPublicUser {
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'avatarUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'nickName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelsPublicUser
     */
    'profileUrl'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return all available API tokens
         * @summary Get API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiTokensGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/api-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Callback for github OAuth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubCallbackGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/github/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Entrypoint for login
         * @summary Login
         * @param {string} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubLoginGet: async (provider: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('authGithubLoginGet', 'provider', provider)
            const localVarPath = `/auth/github/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete API token
         * @summary Delete API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenDelete: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create API token
         * @summary Create API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return found user by provided token
         * @summary Verify user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Return all available API tokens
         * @summary Get API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authApiTokensGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseArrayModelsAPITokenAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authApiTokensGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Callback for github OAuth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGithubCallbackGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGithubCallbackGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Entrypoint for login
         * @summary Login
         * @param {string} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authGithubLoginGet(provider: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseHandlersOAuthRedirectDataAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authGithubLoginGet(provider, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete API token
         * @summary Delete API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenDelete(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create API token
         * @summary Create API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseModelsAPITokenAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return found user by provided token
         * @summary Verify user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authVerifyGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseModelsPublicUserAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authVerifyGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Return all available API tokens
         * @summary Get API tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authApiTokensGet(options?: any): AxiosPromise<HandlersHttpResponseArrayModelsAPITokenAny> {
            return localVarFp.authApiTokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Callback for github OAuth
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubCallbackGet(options?: any): AxiosPromise<object> {
            return localVarFp.authGithubCallbackGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Entrypoint for login
         * @summary Login
         * @param {string} provider provider
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authGithubLoginGet(provider: string, options?: any): AxiosPromise<HandlersHttpResponseHandlersOAuthRedirectDataAny> {
            return localVarFp.authGithubLoginGet(provider, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet(options?: any): AxiosPromise<object> {
            return localVarFp.authLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete API token
         * @summary Delete API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenDelete(options?: any): AxiosPromise<object> {
            return localVarFp.authTokenDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Create API token
         * @summary Create API token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost(options?: any): AxiosPromise<HandlersHttpResponseModelsAPITokenAny> {
            return localVarFp.authTokenPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Return found user by provided token
         * @summary Verify user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authVerifyGet(options?: any): AxiosPromise<HandlersHttpResponseModelsPublicUserAny> {
            return localVarFp.authVerifyGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Return all available API tokens
     * @summary Get API tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authApiTokensGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authApiTokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Callback for github OAuth
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGithubCallbackGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGithubCallbackGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Entrypoint for login
     * @summary Login
     * @param {string} provider provider
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authGithubLoginGet(provider: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authGithubLoginGet(provider, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete API token
     * @summary Delete API token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenDelete(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create API token
     * @summary Create API token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenPost(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return found user by provided token
     * @summary Verify user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authVerifyGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authVerifyGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotesApi - axios parameter creator
 * @export
 */
export const NotesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk update or insert notes
         * @summary Upsert notes
         * @param {Array<ModelsNote>} notes Notes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesBulkUpsertPut: async (notes: Array<ModelsNote>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'notes' is not null or undefined
            assertParamExists('notesBulkUpsertPut', 'notes', notes)
            const localVarPath = `/notes/bulk-upsert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notes, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all notes with optional filter
         * @summary Get notes
         * @param {number} limit Limit for pagination
         * @param {number} offset Offset for pagination
         * @param {string} [userId] User ID
         * @param {string} [searchText] Search text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesGet: async (limit: number, offset: number, userId?: string, searchText?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('notesGet', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('notesGet', 'offset', offset)
            const localVarPath = `/notes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (searchText !== undefined) {
                localVarQueryParameter['searchText'] = searchText;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return graph model with links between connected notes
         * @summary Get notes graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesGraphGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/notes/graph`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get note by id
         * @summary Get note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesIdGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notesIdGet', 'id', id)
            const localVarPath = `/notes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create note
         * @summary Create note
         * @param {ModelsNote} note Note model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesPost: async (note: ModelsNote, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'note' is not null or undefined
            assertParamExists('notesPost', 'note', note)
            const localVarPath = `/notes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(note, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotesApi - functional programming interface
 * @export
 */
export const NotesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotesApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk update or insert notes
         * @summary Upsert notes
         * @param {Array<ModelsNote>} notes Notes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesBulkUpsertPut(notes: Array<ModelsNote>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesBulkUpsertPut(notes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all notes with optional filter
         * @summary Get notes
         * @param {number} limit Limit for pagination
         * @param {number} offset Offset for pagination
         * @param {string} [userId] User ID
         * @param {string} [searchText] Search text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesGet(limit: number, offset: number, userId?: string, searchText?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseArrayModelsNoteModelsPagination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesGet(limit, offset, userId, searchText, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return graph model with links between connected notes
         * @summary Get notes graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesGraphGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseModelsNoteGraphAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesGraphGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get note by id
         * @summary Get note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesIdGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseModelsNoteAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesIdGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create note
         * @summary Create note
         * @param {ModelsNote} note Note model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notesPost(note: ModelsNote, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notesPost(note, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotesApi - factory interface
 * @export
 */
export const NotesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotesApiFp(configuration)
    return {
        /**
         * Bulk update or insert notes
         * @summary Upsert notes
         * @param {Array<ModelsNote>} notes Notes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesBulkUpsertPut(notes: Array<ModelsNote>, options?: any): AxiosPromise<object> {
            return localVarFp.notesBulkUpsertPut(notes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all notes with optional filter
         * @summary Get notes
         * @param {number} limit Limit for pagination
         * @param {number} offset Offset for pagination
         * @param {string} [userId] User ID
         * @param {string} [searchText] Search text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesGet(limit: number, offset: number, userId?: string, searchText?: string, options?: any): AxiosPromise<HandlersHttpResponseArrayModelsNoteModelsPagination> {
            return localVarFp.notesGet(limit, offset, userId, searchText, options).then((request) => request(axios, basePath));
        },
        /**
         * Return graph model with links between connected notes
         * @summary Get notes graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesGraphGet(options?: any): AxiosPromise<HandlersHttpResponseModelsNoteGraphAny> {
            return localVarFp.notesGraphGet(options).then((request) => request(axios, basePath));
        },
        /**
         * get note by id
         * @summary Get note
         * @param {string} id Note ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesIdGet(id: string, options?: any): AxiosPromise<HandlersHttpResponseModelsNoteAny> {
            return localVarFp.notesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create note
         * @summary Create note
         * @param {ModelsNote} note Note model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notesPost(note: ModelsNote, options?: any): AxiosPromise<object> {
            return localVarFp.notesPost(note, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotesApi - object-oriented interface
 * @export
 * @class NotesApi
 * @extends {BaseAPI}
 */
export class NotesApi extends BaseAPI {
    /**
     * Bulk update or insert notes
     * @summary Upsert notes
     * @param {Array<ModelsNote>} notes Notes list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesBulkUpsertPut(notes: Array<ModelsNote>, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesBulkUpsertPut(notes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all notes with optional filter
     * @summary Get notes
     * @param {number} limit Limit for pagination
     * @param {number} offset Offset for pagination
     * @param {string} [userId] User ID
     * @param {string} [searchText] Search text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesGet(limit: number, offset: number, userId?: string, searchText?: string, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesGet(limit, offset, userId, searchText, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return graph model with links between connected notes
     * @summary Get notes graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesGraphGet(options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesGraphGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get note by id
     * @summary Get note
     * @param {string} id Note ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesIdGet(id: string, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create note
     * @summary Create note
     * @param {ModelsNote} note Note model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotesApi
     */
    public notesPost(note: ModelsNote, options?: AxiosRequestConfig) {
        return NotesApiFp(this.configuration).notesPost(note, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagsApi - axios parameter creator
 * @export
 */
export const TagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return list of al registered tags
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagsApi - functional programming interface
 * @export
 */
export const TagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Return list of al registered tags
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tagsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HandlersHttpResponseArrayStringAny>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tagsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagsApi - factory interface
 * @export
 */
export const TagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagsApiFp(configuration)
    return {
        /**
         * Return list of al registered tags
         * @summary Get tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tagsGet(options?: any): AxiosPromise<HandlersHttpResponseArrayStringAny> {
            return localVarFp.tagsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagsApi - object-oriented interface
 * @export
 * @class TagsApi
 * @extends {BaseAPI}
 */
export class TagsApi extends BaseAPI {
    /**
     * Return list of al registered tags
     * @summary Get tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagsApi
     */
    public tagsGet(options?: AxiosRequestConfig) {
        return TagsApiFp(this.configuration).tagsGet(options).then((request) => request(this.axios, this.basePath));
    }
}


